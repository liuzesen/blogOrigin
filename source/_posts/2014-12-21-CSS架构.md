title: CSS架构
date: 2014-12-21 15:53:52
categories:
- 翻译
tags:
- css
---
CSS架构
=======
> 作者：Philip Walton 谷歌工程师
> 发表时间：2012.11.16

[appfolio blog]: http://engineering.appfolio.com/2012/11/16/css-architecture/ "appfolio blog"
> 这篇文章最初发表在[appfolio工程技术博客][appfolio blog]。经过允许，我们将其再版在此。

对很多Web开发者来说，在CSS方面在行意味着你可以建立一个可视的模型并且能够成功地在代码中复用它。你不是用表单布局，你为使用尽可能少的图片布局感到自豪。如果你真的在行，你还会使用最新、最伟大的技术，例如媒体查询（media queries）、过渡（transitions）和变形（transorms）。尽管所有这些技术对CSS开发者来说都极好，但当评估一个人的技能时，还是要把CSS做为单独的一块，尽管这一点很少被提及。

有趣的是，在其他语言上我们不会有这样的疏忽。一个Ruby on Rails开发者不会被认为优秀，因为他的代码是按规范运作的。这被认为是基础。当然，他的代码必需按照规范来做；他的价值体现在：代码可读性强乎？是否易修改或易扩展？是否与应用中的其他模块解耦？是否具有收缩性？

这些问题在评估编码底子的其他部分也是正常的，CSS也不例外。现在的web应用比以住都要大，一个没有经过深思熟虑的CSS架构会使应用作废。我们需要像评价应用其他部分一样评价CSS。不能再认为它是事后要想的事情或者仅仅把它归咎为设计师的问题。

好的CSS架构的目标
-----------------
[hacker news]: https://news.ycombinator.com/item?id=2658948 "Hacker News"
[reaction of developers]: http://2002-2012.mattwilcox.net/archive/entry/id/1054/ "reaction of developers"
[csslint]: http://csslint.net/ "CSS Lint"
在CSS社区，公认的最佳实践是非常难形成的。仅仅通过[comments on Hacker News][hacker news]和[reaction of developers][reaction of developers]发布的[CSS Lint][csslint]工具来校验，显然，大多数人都不会同意这些标准，甚至是最基础的应该做和不应该做的东西都不同意。

因此，我认为我们应该从定义我们的目标开始，而不是列举出我自己的最佳实践的论证。如果我们能够同意这些目标，那我们就有希望挑出坏的CSS，不是因为它破坏了我们预想的对好CSS的观念，而是因为它确实阻碍了开发者的进度。

我相信，好的架构的目标不应该与其它好的应用软件的目标不同。我也希望我的CSS能够变得可预测、可复用、可维护以及可扩展。

### 可预测
可预测的CSS意味着你的规则能像你想的那样表现。当你添加或者更新一个规则时，它不应该影响你网站中不打算改变的部分。在较少改变的小网站，可预测并不重要，但是在拥有成十上千的大网站中，可预测是必需的。

### 可复用
CSS规则应该是抽象的并且充分解耦，只有这样你才能利用现有的部分快速构建组件，而不需要重新编写规则和已经解决的问题。

### 可维护
当你的网站需要添加、更新或者重组新的组件和特性时，不应该要求重构CSS。将组件X添加到页面不应该打破组件Y的存在。

### 可扩展
伴随着你的网站的规模和复杂度的增长，一般都需要更多的开发者去维护。可扩展意味着网站能够轻易地被一个人或者一个大的工程团队管理。也意味着你的网站的CSS架构容易上手，而不是需要过大的学习曲线。当下，仅仅因为你是唯一接触CSS的人并不意味着总是这样。

常见的坏实践
----------
在我们探究实现好优秀CSS架构的方式之前，我认为探究一下实现我们目标的方式中的坏实践是有帮助的。只有通过重复犯错后才能拥抱替代的方法。

下面的例子都是我曾经写过的代码的概括，并且，经过技术地评估，每一个都会导致灾难、让人头疼。违背我的意向、与我许诺效果的不一样，这些规则不断地让我置身困难。

### 在父元素的基础上修改组件
几乎每一个网站都会有一个特别的可视元素，它恰恰和其它元素只有一个外观不同。当面对这种一次性的情况时，几乎每一个CSS开发新手（甚至是资深的开发者）都用同一种方式处理。你们为这个元素找出一些唯一的父元素（或者创建一个），然后你在这些父元素下编写新的规则来处理问题。
```css
.widget {
  background: yellow;
  border: 1px solid black;
  color: black;
  width: 50%;
}

#sidebar .widget {
  width: 200px;
}

body.homepage .widget {
  background: white;
}
```
乍一看这样的代码似乎无害，但是让我们基于建立的目标来检验它。

第一点，例子中书写的小部件是不可预测的。开发者弄几个这样的部件当然可以另它按预想的那样表现，不过当她用在边栏（sidebar）或者在主页中（homepage）使用时，它就会显得不一样，尽管标记元素恰好是一样的。

这样的代码即不能利用也不能扩展。当你希望在主页中（homepage）样式能够用在其他达到目的页面中，会发生什么？新的规则将会加入。

最后，这代码也是难维护的，因为如果部件需要重新被设计，那就需要更新多处的CSS代码，而不像上面的例子，确定这些特殊样式的规则极少展示正确。

相像一下在其它语言中书写这样的代码。首先你定义一个类，然后在你要接触这个类定义的另一部分代码中，你为了一个特殊的用户示例而修改了它。这直接违背了软件开发中的开放/关闭原则：

>软件实体（比如类、模块、方法等）应该对扩展开放，对修改关闭。

之后我们将看到如何修改组件而不依赖于它的父选择器。

### 过于复杂的选择器
偶然间，在网络上会有一篇文章介绍如何使用强大的CSS选择器，并声明你能够在不使用使用类或者ID的情况下设计整站。

尽管技术上是可行的，但是，我越是使用CSS开发，我越偏向于远离复杂的选择器。选择器越复杂，他们与HTML就越耦合。依赖HTML标签和兄弟选择器使你的HTML非常干净，但同时使你的CSS变得一团糟。
```css
#main-nav ul li ul li div {}
#content article h1:first-child {}
#sidebar > div > h3 + p {}
```
以上的例子产生了逻辑感。第一个例子可能是在设计一个下拉菜单，第二个表明文章的主要标题应该和其它的``h1``元素不一样，最后一个例子似乎在给边栏部分的第一个段落添加一些额外的空间。

如果HTML永远不会变，可以证明它的优点，但是，假设HTML永远不变能有多可靠？过度复杂的选择器能够让人印象深刻，它们能够远离用于设置HTML样式用的钩子元素，但是，它们对我们CSS架构的目标的实现没有任何帮助。

所有的例子都没有复用性可言。尽管这些选择器都指向了一个标记中非常特殊的位置，但是试问一个不同格式的HTML如何复用这些样式？就拿第一个例子来做例子（下拉菜单），假如在一个不同的页面需要一个长得一样的下拉菜单，但偏偏它不在``#main-nav``元素里会怎样？你需要重新创建整个样式。

如果HTML格式需要改变，这些选择器样式也难以预测。想一下一个开发者希望将第三个例子中的``<div>``改为``<section>``，整个规则都会被破坏了。

最后，由于只有在HTML格式一层不变下这些选择器才能正常工作，表明它们是难维护和扩展的。

在大型的应用中你需要进行权衡和妥协。用复杂结构的选择性的脆弱来换HTML的“干净”并不值得。

### 过度创建类名
当创建可复用的组件时，我们经常会限定这个组件中子元素的类名。例如：
```css
<div class="widget">
  <h3 class="title">...</h3>
  <div class="contents">
    Lorem ipsum dolor sit amet, consectetur adipiscing elit.
    In condimentum justo et est dapibus sit amet euismod ligula ornare.
    Vivamus elementum accumsan dignissim.
    <button class="action">Click Me!</button>
  </div>
</div>
```

```css
.widget {}
.widget .title {}
.widget .contents {}
.widget .action {}
```
这个想法的思路是，``.title``，``.content``，``.action``这些子元素类能够被安全地设计样式，而不用担心这些样式溢出其它拥有相同类名的元素中。这是可行的，但是它不能防止这些相同名称的类的样式涌进在组件内部。

一个大型的网站，像``.title``这样的类名可能会在其它上环境中甚至自己的环境中。如果这个发生，则部件的标题的样式会变得难以预测。

过度创建类名会导致极不可预测的CSS。

### 一个规则做太多事
有时候你希望在你的网站中创建一个相对于section顶角和左角20像素的组件：
```css
.widget {
  position: absolute;
  top: 20px;
  left: 20px;
  background-color: red;
  font-size: 1.5em;
  text-transform: uppercase;
}
```
接下来你将它用在不同的地方。上面的CSS是行不通的因为它不能在不同的环境中复用。

问题就在你让一个选择器做太多事情了。你在同一个规则中不仅定义了它的外观，而且还设置了它的布局和定位。样式是复用的，但布局和定位不行。当他们被用在一起，整个规则就很脆弱了。

尽管这些规则乍一看没有什么危害，但是它常常会导致没有CSS悟性的开发者复制和粘贴CSS代码。如果一个新的团队成员希望使用一个特别的组件，比如``.infobox``，他会尝试使用这个类。但是如果因为它的样子导致了一个不想要的定位而不能照常工作，他们会怎样做？根据我的经验，大多数初学开发者不会破坏其中可复用的部分。取而代之，他们只会复制和粘贴他们需要的代码行到一个新的选择器，仅仅多余地复制着代码。

原因
---
所有这些坏实践都有一个共同点，他们将太多的样式埋在CSS中了。

这论证看起来很陌生。毕竟，这是样式表，难道他们就不能承受大多数的样式么？这不是我们想我的吗？

最简单的回答就是：“是的”，但是，事情往往不会这么简单。分离表现和内容是好事情，但是不仅仅是因为你的CSS与你的HTML分离并不意味着你的表现与你的内容分离。换一种方式，如果你的CSS需要知道你的HTML格式才能工具的话，把所有样式从你的HTML中抽离并不会实现我们的目标。

此外，HTML也不仅仅只有内容；他们也是结构。而且这样的结构往往由除了允许CSS隔离特定的元素组之外没有任何目的的容器元素组成。甚至没有表现的类，这些样式仍然清楚地嵌入到HTML中。但是，是否有必要在内容中嵌入表现？

我认为，给定HTML和CSS，让HTML和CSS共同做为表现层是有必要的也是明智的。内容层仍然可以通过模板和局部模板来进行抽象。

解决方式
-------
如果你的HTML和CSS共同组成web应用中的表现层，他们需要按照能够提升好架构原则的方式进行。

我发现最好的方法就是为你的CSS假设一个尽可能小的HTML结构。CSS能够定义一系列元素的样式，而且（为了尽可能地与HTML解耦）这些元素应该不管出现在HTML的什么地方看起来都一样。如果一个组件在一个不同的环境下样式不同，它应该有其它命名并且应该由HTML负责去调用它。

考虑一个通过``.button``类来定义一个按钮组件的例子。如果HTML希望一个特别的组件看起来像按钮，它应该使用这个类。如果有需要使得这个按钮看起来不同（也许更大、更宽），这些CSS应该被定义在一个新的类中，然后HTML能够包含这个新类来使用新的样式。

CSS定义你的组件的样式，HTML则将其指派到页面中的元素。CSS越少知道HTML结构越好。

仅仅声明你HTML需要的东西有一个巨大的好处就是允许其它开发者看到标记并且仅仅知道这个元素会长什么样。意图很明显。没有这种习惯，是无法分辨一个元素的样式是有意图的还是偶然的，而且这样还会在团队里导致混乱。

在标记里放置许多类的一个缺陷就是需要额外的努力去完成这些工作。一个单独的CSS规则可以以一个特殊组件的千百个实例为目标。仅仅为确定这个类在标记中被声明而编写它一千次是否值得？

尽管这个问题显然是有效的,但它可能会误导人。这暗示着，不管你在CSS中使用父选择器还是你手动在HTML编写类一千遍，但是显然还有其它方式。在Rails或者其它框架中视图等级抽象可以保证在HTML中正确地显示，而不是必需一遍又一遍地编写相同的类。

好的实践
-------
重复了以上错误一遍一遍和付出代价之后，我们来看看接下来的一些建议。我无意综合地概述，我的经验显示，根据这些原则将帮助你实现更加优秀的CSS架构。

### 变得有意图
确保你的选择器不会影响你不想要的元素的最佳方法是还给它们任何机会。一个例如``#main-nav ul li ul li div``的选择器可以轻易地结束应用于不想要的元素的问题，只要你的标记根据以下方式修改。一个名为``.subnav``的样式，另一方面来说，绝对没有机会意外地应用于你不想要的元素中。将类直接应用于你想设计的元素是保证你的CSS可预测的最佳方式。

```css
/* 手榴弹 */
#main-nav ul li ul { }

/* 狙击步枪 */
.subnav { }
```
给出以上两个例子，相像一个第一个像手榴弹而第二个像狙击步枪。手榴弹可能今天工作的很好，但是你永远不知道一个无辜的平民哪里走进爆炸半径范围内。

### 分离你的关注点
我已经提过，一个组织良好的组件层能够帮助CSS与HTML结构解耦。另外，你的CSS组件自己也应该是模块化的。组件应该知道如何设计他们并且能够作得很好，但是他们不应该对他们的布局或者定位负责，当然也包括不应该对他们如何根据周围的元素定位作太多的假设。

正常情况下，组件应该定义它们看起来怎样但不包括它们的布局和定位。如果你设置了犹如background、color、和font这样的属性，同样地还设置了position、width、height和margin，你就要当心了。

布局和定义应该用一个单独的布局类或者单独的容器元素。（记住，为了有效地分离表现与内容，你必需分离内容和它的容器。）

### 给你的类添加命名空间
我们已经检验了为什么父选择器在封装上不能100%有效，也防止了交叉污染。一个更好的方法就是为你的类应用命名空间。如果一个元素是一个可视组件的一员，每一个它的子元素都应该使用这个组件的基础类名作为命名空间。
```css
/* 样式交叉污染可能性高 */
.widget { }
.widget .title { }

/* 样式交叉污染可能性低 */
.widget { }
.widget-title { }
```
命名你的类让你的组件能够自包含和模块化。它最小化了一个存在的类会冲突地可能性，有减少了设计其子元素的特异性。

### 使用修饰类扩展组件
当一个存在的组件需要在一个特定的环境看起来有一点不同，创建一个修饰类去扩展它。
```css
/* 坏 */
.widget { }
#sidebar .widget { }

/* 好 */
.widget { }
.widget-sidebar { }
```
我们已经看到了基于父元素修改组件的缺点，但是重申一下：一个修饰类能够到处使用。基于位置的重写只能够在特定的位置使用。修饰类能够如你需要地使用。最后，修饰类能够非常清楚地表明你在HTML中的意向。位置基础的类，从另一方面讲，单单看着HTML，它们是对开发者完全不可见的，大大地增加了它们被忽略的可能性。

### 将你的CSS组织到一个逻辑结构中
[Jonathan Snook]: http://snook.ca/ "Jonathan Snook"
[SMACSS]: http://smacss.com/ "Scalable andModular Architecture for CSS"
[Jonathan Snook][Jonathan Snook]在它的著作[SMACSS][SMACSS]中，提出将的CSS规则组织成四个单独的各类：基础类（base）、布局类（layout）、模块类（modules）和状态类（state）。基础类由重置规则和元素默认样式组成。布局类是为网站内的元素定位和创建布局帮助类的，如栅栏系统。模块类是可复用的可视组件。状态类是能够通过javascript进行开和关的样式。

在SMACSS系统中，模块（和我说的组件是等价的）包含最大最主要的CSS规则，所以我发现将它们分解为抽象的模板是有必要的。

组件是独立的可视元素。而模板，从另一方面说，像建设块。模板不会自己单独一个，也很少描述外观和感觉。取而代之，它们是能够放在一起组成组件的单独的、重复的模式。

为了提交一下真实的例子，我们考虑一个模态对话框。这个模态可能有一个网站水印渐变背景，还可能围绕着一个阴影，也可能在右上角有一个关闭按钮，还有，它可能定位是固定的，而且要被水平、垂直居中。四个规则中的每一个都有可能在网站中被一次又一次使用，所以你不会想每一次都重编这些代码。他们本身就是模板，合在一起它们组成了一个模态组件。

我一般不会在HTML中使用模板，除非我有一个好的理由。取而代之，我使用预处理器将这个模板样式导入到组件定义中。晚点我会讨论这些，包含如何合理地做。

### 只将类当作样式来使用
任何曾经在大项目上工作过的都会遇到过完全不知目的的HTML元素。你想移除它，但是你犹豫，因为可能它存在一些你不知道的作用。当这个一次一次地发生，你的HTML会充满那些团队成员都害怕删除的类。

问题就在于这些类在前端开发中被给予过多的责任。他们规定HTML元素样式，作为javscript的钩子，被添加到HTML作特性探测，被用于自动化测试等等。

这就是问题所在。当类被应用的太多部分使用的话，从HTML中移除他们变得很可怕。

然而，如果建立起共识，主些问题可以被避免。当你在HTML看到类时，你应该可以立即说出它的目的。我的建议是给那些无样式的类添加一个前缀。我使用``.js``作为javascript的前缀，``.supports-``作为现代类。所有没有前缀的类都是用于样式的，也只能用于样式。

这另找到无用的类和移除他们变得容易。你甚至可能通过使用``document.styleSheets``对象里的类交叉引用自动化这个过程。不在``document.styleSheets``中的类都可以安全移除。

正常情况下，由于分离表现和内容是最佳实践，因此分离你的方法和表现也很重要。使用设置样式的类做为javascript的钩子使你的CSS和javascript深深耦合在一起，致使你难以甚至不可能在不破坏方法的情况下更新特定元素的样式。

### 使用一个逻辑结构命名你的类
[Nicolas Gallagher]: http://nicolasgallagher.com/ "Nicolas Gallagher"
[ng blog]: http://nicolasgallagher.com/about-html-semantics-front-end-architecture/ "About HTML semantics and front-end architecture"
现在很多人写CSS时使用连字符作为分词符。但连字符不足以区分不同的类。
[Nicolas Gallagher][Nicolas Gallagher]最近写了关于如何处理这个问题的[文章][ng blog]，文章中的方法取得了很大的成功。为了用例子说明命名意识，考虑以下代码：
```css
/* 一个组件 */
.button-group { }

/* 一个组件修饰符 (modifying .button) */
.button-primary { }

/* 一个组件的子元素 (lives within .button) */
.button-icon { }

/* 这是一个组件类还是布局类呢? */
.header { }
```
从这些类可以看出，分辨出他们是应用于什么规则是很困难。这不仅会给开发者带来困惑，也为你的CSS和HTML自动化测试带来困难。一个结构化的命名共识允许你一个看类名就准确地知道它与其它类的关系以及它将在HTML什么位置出现---使得命名更简单，自动化测试也成为可能。
```css
# 模板规则 (使用了sass占位符)
%template-name { }
%template-name--modifier-name { }
%template-name__sub-object { }
%template-name__sub-object--modifier-name { }

# 组件规则
.component-name { }
.component-name--modifier-name { }
.component-name__sub-object { }
.component-name__sub-object--modifier-name { }

# 布局规则
.l-layout-method { }
.grid { }

# 状态规则
.is-state-type { }

# 无样式JS钩子
.js-action-name { }
```
第一个例子重构：
```css
/* 一个组件  */
.button-group { }

/* 一个组件修饰类 (modifying .button) */
.button--primary { }

/* 一个组件子元素 (lives within .button) */
.button__icon { }

/* 一个布局类 */
.l-header { }
```

工具
---
维护一份高效和组织良好的CSS架构非常困难，特别是在大团队里。这里那里的一些小的坏规则会滚雪球般成为难以管理的东西。一旦你应用的CSS进行了特别战争的国度以及使用``!important``的王牌，开始后几乎不可能恢复。关键是从一开始就度绝这些麻烦。

幸运的是，有一些工具能够帮助你更容易地控制你的CSS架构。

### 预处理器
今时今日讲CSS工具是不能不提及预处理器的，因此，本文也不例外。但是在赞扬它的好用前，我应该声明一些注意点。

预处理器只是帮助我们更快地写CSS而不是更好。最终它们还是会编译成CSS，同样的规则会被应用。如果一个预处理器使更快的写CSS地同时也使你更快地写坏的CSS。因此在想使用预处理器解决问题前明白好的CSS架构是很重要的。

许多所谓的预处理器的特点对CSS架构都是不好的。下面是一些这些特性，我会避免它们。（并且尽管这些想法在所有的预处理器中都实现，这些建议是根据sass来讲的）。

* 绝不仅仅为了代码组织而嵌套规则。只有当输出的CSS是你想要的才进行嵌套。
* 如果你不传参，绝不使用mixin。不带参的mixin最好使用可扩展的模板代替。
* 绝不在一个不是单独的类的选择器中使用``@extend``。它从设计的角度来看是没有意义的，而且它使编译的CSS膨胀。
* 绝不在组件修饰类中为UI组件使用``@extend``，因为你将会失去继承链。

预处理器最精华的部分就是``@extend``和``%placeholder``。两者都让你更轻松地管理CSS抽象而不需要添加多余的CSS和在HTML中难以管理的一大堆的基础类。

``@extend``应该小心使用因为有时你需要这样的类在HTML中。作为例子，当你初学``@extend``时，你可能会吸引你在所有的修饰类中使用，就像下面一样：
```css
.button {
  /* 按钮样式 */
}

/* 不好 */
.button--primary {
  @extend .button;
  /* 修饰类样式 */
}
```
这样做的问题就是你失去了HTML中样式的继承链。现在很难通过javascript去选择所有的``.button``实例了。

做为一下常规，我从不继承UI组件或者任何我迟点可能需要知道的样式。这就是模板的作用以及另一种分辨模板和组件的方式。一个模板是一些你从不需要在你的应用逻辑中关心的东西，因此，它们可以很安全地使用预处理器继承。

这里使用以上提到的模态例子来说明代码看起来会是怎样的：
```css
.modal {
  @extend %dialog;
  @extend %drop-shadow;
  @extend %statically-centered;
  /* 其它的模态样式 */
}

.modal__close {
  @extend %dialog__close;
  /* 其它的关闭按钮样式 */
}

.modal__header {
  @extend %background-gradient;
  /* 其它的头样式 */
}
```

### CSS Lint
[Nicole Sullivan](http://www.stubbornella.org/content/page/2/)和[Nicholas Zakas](http://www.nczonline.net/)创建了[CSS LINT](http://csslint.net/)作为一种帮助开发者发现坏习惯的质量工具。他们的网站是这样描述的：
>CSS Lint指出你CSS代码的问题。它执行基本的语法检测和应用一套规则集来找出有问题的模式和低效率的地方。“规则”是可插拨的，所以你可以轻易地写出你自己的或者忽略你不想要的规则。

由于正常的规则集可能不能满足大多数的项目，CSS Lint最大的特性就是能够精准地自定义你想要的规则。这意味着你可以从默认的规则列表中选择或者自己写。

像CSS Lint这样的工具对任何需要确保最低的一致性和约定大团队来说是必需的。就像我前面说的那样，需要约定的最大理由就是他们能让像CSS Lint这样的工具能够轻易地发现问题然后找出来。

基于我们前面建议的共识，我们很容易写出检测特殊反模式的规则。这里有一些建议：

* 选择器中不允许有ID。
* 不要在任何多部分规则中使用无语义的类型选择器（如div,span）。
* 不要在选择器中使用多于2个的兄弟选择器。
* 不要让任何类名以“js-"开头。
* 当频繁使用无"l-"开头的规则来进行布局和定位时要注意。
* 当一个定义了自己的类之后在其它地方被作为子元素重定义时要注意。

这些只是建议，不过它们使你想如何去执行你自己项目的标准。

HTML检查器
---------
之前我建议过，如果一个类在HTML被使用但是没有定义任何样式应该很容易被搜索出来。现在我开发了一个叫做[HTML Inspector](https://github.com/philipwalton/html-inspector/)的工具来使这一过程更简单。

HTML检查器遍历你的HTML，并允许你编写自己的规则来抛出错误和提示。不现在使用下面的规则：
* 在同样的ID被使过超过一次时提示。
* 不要使用没有涉及到任何样式的类或者只允许一些白名单。
* 修饰类不应该在没有基础类的时候使用。
* 子类不应该在没有父类的时候使用。
* 空的DIV或者SPAN元素，没有任何类关联，不应该被使用。

总结
---
CSS不仅仅只是视觉设计。不要抛开我们最佳的编程习惯仅仅因为你在写CSS。像OOP（面向对象）、DRY（Don't repeat yourself）、开放/关闭原则和关注分离等等，一样适用于CSS。

底线是，不管你如何组织你的代码，确保你是这样审判你的方法的：你的方法在长远来看，应该能够帮助你更轻松的开发，更轻松的维护。

原文：[CSS Architecture http://philipwalton.com/articles/css-architecture/](http://philipwalton.com/articles/css-architecture/)